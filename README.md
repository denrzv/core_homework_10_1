# Project: core_homework_10_1

## Описание работы JVM на примере проекта

***

### Запуск программы начинается с загрузчиков:

* Первым будет **Application ClassLoader**, который будет пытаться загрузить из своего кэша класс *JvmComprehension, Object, Integer, String, PrintStream* поскольку эти классы явно используются в методах класса программы. 
* Если в кэше классов не окажется, запрос будет передан далее к **Platform ClassLoader**, который в свою очередь будет искать в кэше и передавать при необходимости запрос выше к последнему загрузчику.
* **Bootstrap ClassLoader** аналогично будет искать в кэше и пытаться найти класс в доступной ему папке со стандартными пакетами *jre/lib*, при отсутствии в ней классов, передавать запрос обратно **PlatformClassLoader**.
* **PlatformClassLoader** будет искать в своей папке *jre/lib/ext* и при отсутствии передавать запрос обратно **Application ClassLoader**, который также будет искать в папке заданной через переменную среды *CLASSPATH*.

### После загрузки классов будет происходить связывание, в частности:

* Проверка кода на валидность
* Подготовка примитивов в статических полях, в примере их нет
* Разрешение символьных ссылок:
    ```java
    Object o = new Object();        // 2
    Integer ii = 2;                 // 3
    Integer uselessVar = 700;       //5
    ```
  
### Затем произойдёт инициализация статических полей и инициализаторов классов

### Произойдёт запуск программы

* Через метод *main* объекта класса *JvmComprehension*

    ```java
    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }
    ```
  * При этом в **Metaspace** попадёт информация о загруженных классах.
  * В **Heap** выделится память для объекта класса *JvmComprehension, Object, String, Integer, PrintStream* 
  * В **Stack** будет создан фрейм внутри которого будет выделена память и сохранены значимые переменные, такие как:
    ```java
    int i = 1;                      // 1
    Object o = new Object();        // 2 только само имя о, которое используется для ссылки на соответствующий объект
    Integer ii = 2;                 // 3 только имя ii
    ```
  
* При выполнении метода *main* произойдёт обращение к объекту класса *JvmComprehension* и вызов метода *printAll*:
  ```java
  private static void printAll(Object o, int i, Integer ii) {
  Integer uselessVar = 700;                   // 5
  System.out.println(o.toString() + i + ii);  // 6
  }
  ```
  * При этом в **Heap** будет выделена память под объекты классов *Integer, String*
  * В **Stack** будет создан фрейм, в котором будет выделена память под значимые типы с именами, а также значениями примитивов: 
  ```java
  uselessVar, o, i, ii
  ```
* По завершению работы метода *printAll* будет по расписанию вызван **Garbage Collector**, который удалит фрейм, 
  связанный с методом, а также ссылки на объекты, которые использовались внутри метода. В частности:
  ```java
  uselessVar, String объект o.toString()
  ```
* После завершения метода выполнится последний статический метод, создавая объект String в **Heap**
  ```java
  System.out.println("finished"); // 7
  ```